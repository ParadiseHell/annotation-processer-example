package com.paradisehell.compiler;

import java.io.IOException;
import java.io.Writer;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import javax.annotation.processing.AbstractProcessor;
import javax.annotation.processing.RoundEnvironment;
import javax.annotation.processing.SupportedAnnotationTypes;
import javax.annotation.processing.SupportedOptions;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.Element;
import javax.lang.model.element.ExecutableElement;
import javax.lang.model.element.TypeElement;
import javax.lang.model.element.VariableElement;
import javax.lang.model.type.TypeMirror;

@SupportedAnnotationTypes(value = { "com.paradisehell.api.annotation.SubscribeOnMainThread" })
@SupportedOptions(value = { "POST_OBJECT_ON_MAIN_THREAD_INDEX" })
public final class AnnotationCompiler extends AbstractProcessor {
  //<editor-fold desc="常量">
  private static final String POST_OBJECT_ON_MAIN_THREAD_INDEX = "POST_OBJECT_ON_MAIN_THREAD_INDEX";
  //</editor-fold>

  //<editor-fold desc="属性">
  private Map<TypeElement, List<ExecutableElement>> mMethodsByClass = new HashMap<>();
  //</editor-fold>

  //<editor-fold desc="方法重写">

  @Override
  public SourceVersion getSupportedSourceVersion() {
    return SourceVersion.latestSupported();
  }
  //</editor-fold>

  //<editor-fold desc="方法实现">

  @Override
  public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment evn) {
    try {
      String index = processingEnv.getOptions().get(POST_OBJECT_ON_MAIN_THREAD_INDEX);
      if (index != null && !annotations.isEmpty()) {
        // 获取包名和文件名
        String packageName = null, clazz;
        int packageNameIndex = index.lastIndexOf(".");
        if (packageNameIndex != -1) {
          packageName = index.substring(0, packageNameIndex);
          clazz = index.substring(packageNameIndex + 1);
        } else {
          clazz = index;
        }
        // 循环注解
        for (TypeElement annotation : annotations) {
          // 获取带有该注解标记的所有元素
          Set<? extends Element> elements = evn.getElementsAnnotatedWith(annotation);
          // 循环元素列表
          if (elements != null && !elements.isEmpty()) {
            for (Element element : elements) {
              // 只对方法进行处理
              if (element instanceof ExecutableElement) {
                ExecutableElement method = (ExecutableElement) element;
                // 判断方法的返回值和参数个数
                TypeMirror returnType = method.getReturnType();
                List<? extends VariableElement> parameters = method.getParameters();
                // 只处理返回值为 void 并且额只有一个参数的方法
                if ("void".equals(returnType.toString())
                    && parameters != null
                    && parameters.size() == 1) {
                  // 保存订阅者相关方法
                  TypeElement subscriber = (TypeElement) method.getEnclosingElement();
                  List<ExecutableElement> methodList = mMethodsByClass.get(subscriber);
                  if (methodList == null) {
                    methodList = new ArrayList<>();
                    mMethodsByClass.put(subscriber, methodList);
                  }
                  methodList.add(method);
                }
              }
            }
          }
        }
        // 判断是否收集到相关信息
        if (!mMethodsByClass.isEmpty()) {
          // 写入包名
          Writer writer = processingEnv.getFiler().createSourceFile(index).openWriter();
          if (packageName != null) {
            writer.write("package " + packageName + ";\n");
            writer.write("\n");
          }
          // 写入引入的包
          writer.write("import com.paradisehell.api.ISubscriberIndex;\n");
          writer.write("import com.paradisehell.api.ISubscriberInfo;\n");
          writer.write("import com.paradisehell.api.SimpleSubscriberInfo;\n");
          writer.write("import com.paradisehell.api.SubscriberMethodInfo;\n");
          writer.write("import java.util.HashMap;\n");
          writer.write("import java.util.Map;\n");
          writer.write("\n");
          // 写入提示注释
          writer.write("/** This class is generated by EventBus, do not edit. */\n\n");
          // 写入类名
          writer.write("public final class " + clazz + " implements ISubscriberIndex {\n");
          // 定义常量
          writer.write(
              "  private static final Map<Class<?>, ISubscriberInfo> SUBSCRIBER_INFO_BY_CLASS;\n"
          );
          writer.write("\n");
          // 初始化变量
          writer.write("  static {\n");
          writer.write(
              "    SUBSCRIBER_INFO_BY_CLASS = new HashMap<Class<?>, ISubscriberInfo>();\n"
          );
          writer.write("\n");
          // 循环订阅者信息
          for (Map.Entry<TypeElement, List<ExecutableElement>> entry : mMethodsByClass.entrySet()) {
            writer.write("    SUBSCRIBER_INFO_BY_CLASS.put(\n");
            writer.write("        " + entry.getKey().getQualifiedName().toString() + ".class,\n");
            writer.write("        " + "new SimpleSubscriberInfo(new SubscriberMethodInfo[]{\n");
            // 循环方法
            for (ExecutableElement method : entry.getValue()) {
              TypeElement eventType = (TypeElement) processingEnv.getTypeUtils().asElement(
                  method.getParameters().get(0).asType()
              );
              writer.write("          new SubscriberMethodInfo("
                  + "\"" + method.getSimpleName() + "\""
                  + ", "
                  + eventType.getQualifiedName().toString() + ".class"
                  + "),\n"
              );
            }
            writer.write("        })\n");
            writer.write("    );\n");
          }
          writer.write("  }\n");
          writer.write("\n");
          // 方法实现
          writer.write("  @Override\n");
          writer.write("  public ISubscriberInfo getSubscriberInfo(Class<?> subscriberClass) {\n");
          writer.write("    return SUBSCRIBER_INFO_BY_CLASS.get(subscriberClass);\n");
          writer.write("  }\n");
          writer.write("}\n");
          writer.close();
          return true;
        }
      }
    } catch (IOException ignore) {
    }
    return false;
  }
  //</editor-fold>
}
